{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"DES\"\n",
        "execute:\n",
        "  echo: false\n",
        "format:\n",
        "    dashboard:\n",
        "        orientation: columns\n",
        "        embed-resources: true\n",
        "---"
      ],
      "id": "80016467"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: library-imports\n",
        "\n",
        "import pandas as pd\n",
        "\n",
        "import plotly.express as px\n",
        "from itables import show\n",
        "from great_tables import GT\n",
        "import simpy\n",
        "import random\n",
        "import numpy as np\n",
        "import re"
      ],
      "id": "library-imports",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: base_code\n",
        "\n",
        "\n",
        "# Class to store global parameter values\n",
        "class g:\n",
        "    # Inter-arrival times\n",
        "    patient_inter = 3\n",
        "    call_inter = 10\n",
        "\n",
        "    # Activity times\n",
        "    mean_reg_time = 2\n",
        "    mean_gp_time = 8\n",
        "    mean_book_test_time = 4\n",
        "    mean_call_time = 4\n",
        "\n",
        "    # Resource numbers\n",
        "    number_of_receptionists = 1\n",
        "    number_of_gps = 2\n",
        "\n",
        "    # Branch probabilities\n",
        "    prob_book_test = 0.25\n",
        "\n",
        "    # Simulation meta parameters\n",
        "    sim_duration = 480\n",
        "    number_of_runs = 10\n",
        "\n",
        "# Class representing patients coming in to the GP surgery\n",
        "class Patient:\n",
        "    def __init__(self, p_id):\n",
        "        self.id = p_id\n",
        "        self.arrival_time = 0\n",
        "        self.q_time_reg = 0\n",
        "        self.q_time_gp = 0\n",
        "        self.time_with_gp = 0\n",
        "        self.q_time_book_test = 0\n",
        "        self.time_with_receptionist = 0.0\n",
        "\n",
        "# Class representing callers phoning the GP surgery\n",
        "class Caller:\n",
        "    def __init__(self, c_id):\n",
        "        self.id = c_id\n",
        "        self.call_time = 0\n",
        "        self.time_with_receptionist = 0.0\n",
        "        self.q_time_call = 0\n",
        "\n",
        "# Class representing our model of the GP surgery\n",
        "class Model:\n",
        "    # Constructor\n",
        "    def __init__(self, run_number):\n",
        "        # Set up SimPy environment\n",
        "        self.env = simpy.Environment()\n",
        "\n",
        "        # Set up counters to use as entity IDs\n",
        "        self.patient_counter = 0\n",
        "        self.caller_counter = 0\n",
        "\n",
        "        # Set up lists to store patient objects\n",
        "        self.patient_objects = [] ##NEW\n",
        "        self.caller_objects = [] ##NEW\n",
        "\n",
        "        # Set up resources\n",
        "        self.receptionist = simpy.Resource(\n",
        "            self.env, capacity=g.number_of_receptionists\n",
        "        )\n",
        "        self.gp = simpy.Resource(\n",
        "            self.env, capacity=g.number_of_gps\n",
        "        )\n",
        "\n",
        "        # Set run number from value passed in\n",
        "        self.run_number = run_number\n",
        "\n",
        "        # Set up DataFrame to store patient-level results\n",
        "        self.patient_results_df = pd.DataFrame()\n",
        "        self.patient_results_df[\"Patient ID\"] = [1]\n",
        "        self.patient_results_df[\"Arrival Time\"] = [0.0]\n",
        "        self.patient_results_df[\"Queue Time Reg\"] = [0.0]\n",
        "        self.patient_results_df[\"Time Seen For Registration\"] = [0.0]\n",
        "        self.patient_results_df[\"Queue Time GP\"] = [0.0]\n",
        "        self.patient_results_df[\"Time Seen By GP\"] = [0.0]\n",
        "        self.patient_results_df[\"Queue Time Book Test\"] = [0.0]\n",
        "        self.patient_results_df[\"Time Test Booking Started\"] = [0.0]\n",
        "        self.patient_results_df[\"Departure Time\"] = [0.0]\n",
        "        self.patient_results_df.set_index(\"Patient ID\", inplace=True)\n",
        "\n",
        "        # Set up DataFrame to store caller-level results\n",
        "        self.caller_results_df = pd.DataFrame()\n",
        "        self.caller_results_df[\"Caller ID\"] = [1]\n",
        "        self.caller_results_df[\"Call Start Time\"] = [0.0]\n",
        "        self.caller_results_df[\"Queue Time Call\"] = [0.0]\n",
        "        self.caller_results_df[\"Call Answered At\"] = [0.0]\n",
        "        self.caller_results_df[\"Call End Time\"] = [0.0]\n",
        "        self.caller_results_df.set_index(\"Caller ID\", inplace=True)\n",
        "\n",
        "        # Set up attributes that will store mean queuing times across the run\n",
        "        self.mean_q_time_reg = 0\n",
        "        self.mean_q_time_gp = 0\n",
        "        self.mean_q_time_book_test = 0\n",
        "        self.mean_q_time_call = 0\n",
        "\n",
        "        # Set up attributes used to monitor total resource usage\n",
        "        self.receptionist_utilisation_prop = 0.0\n",
        "        self.gp_utilisation_prop = 0.0\n",
        "\n",
        "    # Generator function that represents the DES generator for patient arrivals\n",
        "    def generator_patient_arrivals(self):\n",
        "        while True:\n",
        "            self.patient_counter += 1\n",
        "\n",
        "            p = Patient(self.patient_counter)\n",
        "            self.patient_objects.append(p) ##NEW\n",
        "\n",
        "            self.env.process(self.attend_gp_surgery(p))\n",
        "\n",
        "            sampled_inter = random.expovariate(1.0 / g.patient_inter)\n",
        "\n",
        "            yield self.env.timeout(sampled_inter)\n",
        "\n",
        "    # Generator function that represents the DES generator for caller arrivals\n",
        "    def generator_callers(self):\n",
        "        while True:\n",
        "            self.caller_counter += 1\n",
        "\n",
        "            c = Caller(self.caller_counter)\n",
        "            self.caller_objects.append(c) ##NEW\n",
        "\n",
        "            self.env.process(self.call_gp_surgery(c))\n",
        "\n",
        "            sampled_inter = random.expovariate(1.0 / g.call_inter)\n",
        "\n",
        "            yield self.env.timeout(sampled_inter)\n",
        "\n",
        "    # Generator function representing pathway for patients attending the GP\n",
        "    # surgery to see a GP\n",
        "    def attend_gp_surgery(self, patient):\n",
        "        # Registration activity\n",
        "        start_q_reg = self.env.now\n",
        "        self.patient_results_df.at[patient.id, \"Arrival Time\"] = (\n",
        "                start_q_reg\n",
        "            )\n",
        "\n",
        "        with self.receptionist.request() as req:\n",
        "            yield req\n",
        "\n",
        "            end_q_reg = self.env.now\n",
        "\n",
        "            patient.q_time_reg = end_q_reg - start_q_reg\n",
        "\n",
        "            self.patient_results_df.at[patient.id, \"Queue Time Reg\"] = (\n",
        "                patient.q_time_reg\n",
        "            )\n",
        "            self.patient_results_df.at[patient.id, \"Time Seen For Registration\"] = (\n",
        "                start_q_reg + patient.q_time_reg\n",
        "            )\n",
        "\n",
        "            sampled_reg_time = random.expovariate(\n",
        "                1.0 / g.mean_reg_time\n",
        "            )\n",
        "\n",
        "            patient.time_with_receptionist += sampled_reg_time\n",
        "\n",
        "            yield self.env.timeout(sampled_reg_time)\n",
        "\n",
        "        # GP Consultation activity\n",
        "        start_q_gp = self.env.now\n",
        "\n",
        "        with self.gp.request() as req:\n",
        "            yield req\n",
        "\n",
        "            end_q_gp = self.env.now\n",
        "\n",
        "            patient.q_time_gp = end_q_gp - start_q_gp\n",
        "\n",
        "            self.patient_results_df.at[patient.id, \"Queue Time GP\"] = (\n",
        "                patient.q_time_gp\n",
        "            )\n",
        "            self.patient_results_df.at[patient.id, \"Time Seen By GP\"] = (\n",
        "                start_q_gp + patient.q_time_gp\n",
        "            )\n",
        "\n",
        "            sampled_gp_time = random.expovariate(\n",
        "                1.0 / g.mean_gp_time\n",
        "            )\n",
        "\n",
        "            patient.time_with_gp += sampled_gp_time\n",
        "\n",
        "            yield self.env.timeout(sampled_gp_time)\n",
        "\n",
        "        # Branching path check to see if patient needs to book a test\n",
        "        if random.uniform(0,1) < g.prob_book_test:\n",
        "            # Book test activity\n",
        "            start_q_book_test = self.env.now\n",
        "\n",
        "            with self.receptionist.request() as req:\n",
        "                yield req\n",
        "\n",
        "                end_q_book_test = self.env.now\n",
        "\n",
        "                patient.q_time_book_test = end_q_book_test - start_q_book_test\n",
        "\n",
        "                self.patient_results_df.at[patient.id, \"Queue Time Book Test\"] = (\n",
        "                    patient.q_time_book_test\n",
        "                )\n",
        "\n",
        "                self.patient_results_df.at[patient.id, \"Time Test Booking Started\"] = (\n",
        "                    start_q_book_test + patient.q_time_book_test\n",
        "                )\n",
        "\n",
        "                sampled_book_test_time = random.expovariate(\n",
        "                    1.0 / g.mean_book_test_time\n",
        "                )\n",
        "\n",
        "                patient.time_with_receptionist += sampled_book_test_time\n",
        "\n",
        "                yield self.env.timeout(sampled_book_test_time)\n",
        "\n",
        "            self.patient_results_df.at[patient.id, \"Departure Time\"] = (\n",
        "                self.env.now\n",
        "            )\n",
        "\n",
        "    # Generator function representing callers phoning the GP surgery\n",
        "    def call_gp_surgery(self, caller):\n",
        "        # Answering call activity\n",
        "        start_q_call = self.env.now\n",
        "        self.caller_results_df.at[caller.id, \"Call Start Time\"] = (\n",
        "                start_q_call\n",
        "            )\n",
        "\n",
        "        with self.receptionist.request() as req:\n",
        "            yield req\n",
        "\n",
        "            end_q_call = self.env.now\n",
        "\n",
        "            caller.q_time_call = end_q_call - start_q_call\n",
        "\n",
        "            self.caller_results_df.at[caller.id, \"Queue Time Call\"] = (\n",
        "                caller.q_time_call\n",
        "            )\n",
        "\n",
        "            self.caller_results_df.at[caller.id, \"Call Answered At\"] = (\n",
        "                self.env.now\n",
        "            )\n",
        "\n",
        "            sampled_call_time = random.expovariate(\n",
        "                1.0 / g.mean_call_time\n",
        "            )\n",
        "\n",
        "            caller.time_with_receptionist += sampled_call_time\n",
        "\n",
        "            yield self.env.timeout(sampled_call_time)\n",
        "\n",
        "            self.caller_results_df.at[caller.id, \"Call End Time\"] = (\n",
        "                self.env.now\n",
        "            )\n",
        "\n",
        "    # Method to calculate and store results over the run\n",
        "    def calculate_run_results(self):\n",
        "        self.mean_q_time_reg = self.patient_results_df[\"Queue Time Reg\"].mean()\n",
        "        self.mean_q_time_gp = self.patient_results_df[\"Queue Time GP\"].mean()\n",
        "        self.mean_q_time_book_test = (\n",
        "            self.patient_results_df[\"Queue Time Book Test\"].mean()\n",
        "        )\n",
        "\n",
        "        self.mean_q_time_call = self.caller_results_df[\"Queue Time Call\"].mean()\n",
        "\n",
        "        gp_utilisation_mins = sum([i.time_with_gp for i in self.patient_objects])\n",
        "\n",
        "        receptionist_utilisation_mins = sum(\n",
        "            [i.time_with_receptionist for i in self.patient_objects]\n",
        "            ) + sum(\n",
        "            [i.time_with_receptionist for i in self.caller_objects]\n",
        "            )\n",
        "\n",
        "        self.gp_utilisation_prop = (\n",
        "            gp_utilisation_mins / (g.number_of_gps * g.sim_duration)\n",
        "            )\n",
        "\n",
        "        self.receptionist_utilisation_prop = (\n",
        "            receptionist_utilisation_mins / (g.number_of_receptionists * g.sim_duration)\n",
        "        )\n",
        "\n",
        "\n",
        "    # Method to run a single run of the simulation\n",
        "    def run(self):\n",
        "        # Start up DES generators\n",
        "        self.env.process(self.generator_patient_arrivals())\n",
        "        self.env.process(self.generator_callers())\n",
        "\n",
        "        # Run for the duration specified in g class\n",
        "        self.env.run(until=g.sim_duration)\n",
        "\n",
        "        # Calculate results over the run\n",
        "        self.calculate_run_results()\n",
        "\n",
        "        return self.caller_results_df, self.patient_results_df\n",
        "\n",
        "# Class representing a trial for our simulation\n",
        "class Trial:\n",
        "    # Constructor\n",
        "    def __init__(self):\n",
        "        self.df_trial_results = pd.DataFrame()\n",
        "        self.df_trial_results[\"Run Number\"] = [1]\n",
        "        self.df_trial_results[\"Mean Queue Time Reg\"] = [0.0]\n",
        "        self.df_trial_results[\"Mean Queue Time GP\"] = [0.0]\n",
        "        self.df_trial_results[\"Mean Queue Time Book Test\"] = [0.0]\n",
        "        self.df_trial_results[\"Mean Queue Time Call\"] = [0.0]\n",
        "        self.df_trial_results[\"GP Utilisation - Percentage\"] = [0.0]\n",
        "        self.df_trial_results[\"Receptionist Utilisation - Percentage\"] = [0.0]\n",
        "        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n",
        "\n",
        "    # Method to calculate and store means across runs in the trial\n",
        "    def calculate_means_over_trial(self):\n",
        "        self.mean_q_time_reg_trial = (\n",
        "            self.df_trial_results[\"Mean Queue Time Reg\"].mean()\n",
        "        )\n",
        "        self.mean_q_time_gp_trial = (\n",
        "            self.df_trial_results[\"Mean Queue Time GP\"].mean()\n",
        "        )\n",
        "        self.mean_q_time_book_test_trial = (\n",
        "            self.df_trial_results[\"Mean Queue Time Book Test\"].mean()\n",
        "        )\n",
        "        self.mean_q_time_call_trial = (\n",
        "            self.df_trial_results[\"Mean Queue Time Call\"].mean()\n",
        "        )\n",
        "\n",
        "    # Method to run trial\n",
        "    def run_trial(self):\n",
        "        caller_dfs = []\n",
        "        patient_dfs = []\n",
        "\n",
        "        for run in range(1, g.number_of_runs+1):\n",
        "            my_model = Model(run)\n",
        "            caller_df, patient_df = my_model.run()\n",
        "            caller_df[\"Run\"] = run\n",
        "            caller_df[\"What\"] = \"Callers\"\n",
        "            patient_df[\"Run\"] = run\n",
        "            patient_df[\"What\"] = \"Patients\"\n",
        "\n",
        "            caller_dfs.append(caller_df)\n",
        "            patient_dfs.append(patient_df)\n",
        "\n",
        "            self.df_trial_results.loc[run] = [my_model.mean_q_time_reg,\n",
        "                                              my_model.mean_q_time_gp,\n",
        "                                              my_model.mean_q_time_book_test,\n",
        "                                              my_model.mean_q_time_call,\n",
        "                                              round(my_model.gp_utilisation_prop * 100, 2),\n",
        "                                              round(my_model.receptionist_utilisation_prop*100, 2)\n",
        "                                              ]\n",
        "\n",
        "        return self.df_trial_results.round(1), pd.concat(caller_dfs), pd.concat(patient_dfs)\n",
        "\n",
        "\n",
        "###########################################################\n",
        "# Run a trial using the parameters from the g class and   #\n",
        "# print the results                                       #\n",
        "###########################################################\n",
        "\n",
        "df_trial_results, caller_results, patient_results = Trial().run_trial()\n"
      ],
      "id": "base_code",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Results of simulation\n",
        "\n",
        "::: panel-tabset\n",
        "### main trial results\n"
      ],
      "id": "e0223a1a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: trial_results_display\n",
        "\n",
        "# uses the itables library which includes the buttons\n",
        "show(\n",
        "    df_trial_results,\n",
        "    buttons=[\"copyHtml5\", \"csvHtml5\", \"colvis\"],\n",
        "    )"
      ],
      "id": "trial_results_display",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Sample of patient results timings\n"
      ],
      "id": "efd0ec1c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: patient_results_display\n",
        "\n",
        "# uses the itables library which includes the buttons\n",
        "show(\n",
        "    patient_results.sample(25),\n",
        "    buttons=[\"copyHtml5\", \"csvHtml5\", \"colvis\"],\n",
        "    )"
      ],
      "id": "patient_results_display",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Sample of callers\n"
      ],
      "id": "817e9148"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: caller_results_display\n",
        "\n",
        "# uses the itables library which includes the buttons\n",
        "show(\n",
        "    caller_results.sample(25),\n",
        "    buttons=[\"copyHtml5\", \"csvHtml5\", \"colvis\"],\n",
        "    )"
      ],
      "id": "caller_results_display",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "## Receptionist Stats\n",
        "\n",
        "The median wait for registration across `{python} g.number_of_runs` was `{python} df_trial_results['Mean Queue Time Reg'].median():.0f` minutes\n",
        "\n",
        "The median wait for registration across `{python} g.number_of_runs` was `{python} df_trial_results['Mean Queue Time Reg'].median()` minutes\n"
      ],
      "id": "42640b8c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: summary-statistics\n",
        "#| echo: false\n",
        "\n",
        "median_wait_booking = df_trial_results['Mean Queue Time Book Test'].median():.0f\n",
        "median_wait_callers = df_trial_results['Mean Queue Time Call'].median():.0f\n",
        "median_utilisation_receptionist = df_trial_results['Receptionist Utilisation - Percentage'].median():.0f"
      ],
      "id": "summary-statistics",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The median wait for booking a test was `{python} median_wait_booking` minutes.\n",
        "\n",
        "The median wait for callers to have their call answered was `{python} median_wait_callers` minutes.\n",
        "\n",
        "The median utilisation for a receptionist across `{python} g.number_of_runs` runs was `{python} median_utilisation_receptionist`%.\n"
      ],
      "id": "8fb879c5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "print(f\"The median wait for booking a test \" +\n",
        "      f\"was {df_trial_results['Mean Queue Time Book Test'].median():.1f} minutes\")\n",
        "\n",
        "print(f\"The median wait for callers to have their call answered \" +\n",
        "      f\"was {df_trial_results['Mean Queue Time Call'].median():.1f} minutes\")\n",
        "\n",
        "print(f\"The median utilisation for a receptionist across {g.number_of_runs} \" +\n",
        "      f\"was {df_trial_results['Receptionist Utilisation - Percentage'].median()}%\")\n",
        "\n",
        "print(\"=== GP Stats ===\")\n",
        "\n",
        "print(f\"The median wait for a GP across {g.number_of_runs} \" +\n",
        "      f\"was {df_trial_results['Mean Queue Time GP'].median():.1f} minutes\")\n",
        "\n",
        "\n",
        "print(f\"The median utilisation for a GP across {g.number_of_runs} \" +\n",
        "      f\"was {df_trial_results['GP Utilisation - Percentage'].median()}%\")\n",
        "\n",
        "###########################################################\n",
        "###########################################################\n",
        "# Create some summaries and visualisations for averages   #\n",
        "# across the trial                                        #\n",
        "###########################################################\n",
        "###########################################################\n",
        "\n",
        "# Let's set up a reusable sequence of colours that can give our plotly plots a consistent\n",
        "# feel/identity\n",
        "# This uses some colours from the NHS identity guidelines that should work well when\n",
        "# placed next to each other\n",
        "# https://www.england.nhs.uk/nhsidentity/identity-guidelines/colours/\n",
        "# If we pass this to something with just a single colour in the plot, it will just take the\n",
        "# first colour from the sequence (NHS Blue)\n",
        "# If we pass it to a plot that has categories, it will assign colours to categories\n",
        "# in the order given in this list\n",
        "nhs_colour_sequence = [\"#005EB8\", \"#FFB81C\", \"#00A499\", \"#41B6E6\", \"#AE2573\", \"#006747\"]\n",
        "\n",
        "##############################################\n",
        "# Bar plot - average waits per stage per run #\n",
        "##############################################\n",
        "average_waits_fig = px.bar(\n",
        "    # First we need to get the dataframe into the shape needed by the plot\n",
        "    # We start by dropping the utilisation columns from our dataframe\n",
        "    # as they're on a very different scale to the wait times\n",
        "    df_trial_results.drop(\n",
        "        columns=[\"GP Utilisation - Percentage\",\n",
        "                 \"Receptionist Utilisation - Percentage\"])\n",
        "                 # We then reset the index of the plot so the run number is\n",
        "                 # a column rather than the index of the dataframe\n",
        "                 .reset_index(drop=False)\n",
        "                 # Finally, we use the melt function to turn this from a 'wide'\n",
        "                 # dataframe (where we have a column for each of the different measures)\n",
        "                 # to a 'long' dataframe where we have one row per run/metric combination.\n",
        "                 # After melting, our original column names will be in a column entitled\n",
        "                 # 'variable' and our actual wait times for each stage will be in a column\n",
        "                 # # called 'value'\n",
        "                 # (so a row might look like \"1, Mean Queue Time Reg, 87\" for the 'Run Number',\n",
        "                 # 'variable' and 'value' columns respectively)\n",
        "                 .melt(id_vars=\"Run Number\"),\n",
        "        x=\"value\", # What's on the horizontal axis - this is the number of minutes\n",
        "        y=\"Run Number\", # What's on the vertical axis\n",
        "        facet_col=\"variable\", # This will create a separate plot for each variable (here, the metric)\n",
        "        # Give the whole plot a title\n",
        "        title=\"Average Waits (Minutes) For Each Stage of the Patient Journey - by Run\",\n",
        "        orientation='h', # Set this to a horizontal bar plot (default is vertical)\n",
        "        labels={\"value\": \"Average Wait (Mins)\"}, # Make the label on the x axis nicer\n",
        "        # Use our NHS colour palette; only the first colour will be used as we haven't\n",
        "        # made use of colour as a part of the visualisation in this plot, but this does mean\n",
        "        # that the bars will use the standard NHS blue rather than the plotly one\n",
        "        color_discrete_sequence=nhs_colour_sequence\n",
        "        )\n",
        "\n",
        "# After we use the px.bar function to create our plot, there will be a few additional things\n",
        "# we want to do to the plot before displaying it. There is a limit to what can be done in\n",
        "# the original function call as there are only so many parameters - these little extra touches\n",
        "# just make the plot as readable and polished-looking as possible!\n",
        "\n",
        "# This will tidy up the subtitles of each 'facet' within our plot (the mini-graph relating)\n",
        "# to each of our metrics\n",
        "# This uses what's called a 'lambda' function, which is a little temporary function that in this case\n",
        "# iterates through the annotation text and replaces the string 'variable=' with an empty string,\n",
        "# which just tidies up the headers in this case so it only contains the actual name of the variable\n",
        "average_waits_fig.for_each_annotation(lambda a: a.update(text=a.text.replace(\"variable=\", \"\")))\n",
        "\n",
        "# Here we are going to update the layout to ensure that we have a label for every run number in\n",
        "# our y axis\n",
        "# By default, plotly tries to intelligently choose a scale - but for this, it makes more sense to\n",
        "# include a label for every row (unless we have lots of runs, in which case we won't apply this\n",
        "# correction)\n",
        "if g.number_of_runs < 20:\n",
        "    average_waits_fig.update_layout(yaxis = {'dtick': 1})\n",
        "\n",
        "# Finally, we force plotly to display the plot in the interactive window.\n",
        "# If we don't use this then only the final plotly plot we create will actually be displayed\n",
        "average_waits_fig.show()\n",
        "\n",
        "##############################################\n",
        "# Bar plot - waits per stage per run         #\n",
        "##############################################\n",
        "\n",
        "performance_per_run_fig = px.bar(\n",
        "    # First we need to get the dataframe into the shape needed by the plot\n",
        "    # We start by dropping the utilisation columns from our dataframe\n",
        "    # as they're on a very different scale to the wait times\n",
        "    df_trial_results.drop(\n",
        "        columns=[\"GP Utilisation - Percentage\",\n",
        "                 \"Receptionist Utilisation - Percentage\"])\n",
        "                 # We then reset the index of the plot so the run number is\n",
        "                 # a column rather than the index of the dataframe\n",
        "                 .reset_index(drop=False)\n",
        "                 # This time we use a lambda function (a small temporary function)\n",
        "                 # to look at each of our column names and replace the string\n",
        "                 # 'Mean Queue Time ' with a blank string, which we want to do here\n",
        "                 # as we're going to use those values as our x axis labels and it will\n",
        "                 # get cluttered and hard to read with that phrase used (and we can just make\n",
        "                 # it clear what each value is via other labels or the title)\n",
        "                 .rename(columns=lambda x: re.sub('Mean Queue Time ', '', x))\n",
        "                 # Finally, we reshape the dataframe from a wide to a long format\n",
        "                 # (see the first plot for more details on this)\n",
        "                 .melt(id_vars=\"Run Number\"),\n",
        "    # This time we're going to facet (make mini sub-plots) by run instead - we're aiming to\n",
        "    # end up with a mini-plot per run to look at the performance on a run level rather than\n",
        "    # in the previous plot where we had more ability to look at the performance against a\n",
        "    # single metric across multiple runs - so even though we're using the same data here,\n",
        "    # the focus of the plot is slightly different\n",
        "    facet_col=\"Run Number\",\n",
        "    facet_col_wrap=10, # Ensure that if we have lots of runs, our subplots don't become too small\n",
        "    x=\"variable\", # the column used for our horizontal axis\n",
        "    y=\"value\", # the column used for our vertical axis\n",
        "    # A title for the whole plot\n",
        "    title=\"Average Waits (Minutes) For Each Stage of the Patient Journey - by Run\",\n",
        "    # Make use of our NHS colour scheme (again, as this plot will only use a single colour, it just\n",
        "    # uses the first colour from the list which is the NHS blue)\n",
        "    color_discrete_sequence=nhs_colour_sequence,\n",
        "    # Finally we tidy up the labels, replacing 'variable' with a blank string (as it's very clear\n",
        "    # from the category labels and the other labels on the plot what is displayed there\n",
        "    labels={\"variable\": \"\",\n",
        "            \"value\": \"Queue Time (minutes)\"\n",
        "            })\n",
        "\n",
        "# We cycle through and tidy up the display of the subheaders for the subplots\n",
        "performance_per_run_fig.for_each_annotation(\n",
        "    lambda a: a.update(text=a.text.replace(\"Run Number=\", \"Run \"))\n",
        "    )\n",
        "\n",
        "# This time, as we have multiple x axes in the overall plot (one per subplot) we need to use a\n",
        "# slightly different function to ensure every label will get displayed\n",
        "performance_per_run_fig.for_each_xaxis(lambda xaxis: xaxis.update(dtick=1))\n",
        "\n",
        "# Display the plot\n",
        "performance_per_run_fig.show()\n",
        "\n",
        "###############################################\n",
        "# Box plot - resource utilisation by resource #\n",
        "###############################################\n",
        "\n",
        "utilisation_boxplot_fig = px.box(\n",
        "    # First we need to get the dataframe into the shape needed by the plot\n",
        "    # We start by only selecting the utilisation columns by passing a list of\n",
        "    # the column names inside another set of square brackets\n",
        "    (df_trial_results[[\"GP Utilisation - Percentage\",\n",
        "                 \"Receptionist Utilisation - Percentage\"]]\n",
        "                 # once again we want the run number to be a column, not the index\n",
        "                 .reset_index(drop=False)\n",
        "                 # and once again we want it in long format (see the first plot for details)\n",
        "                 .melt(id_vars=\"Run Number\")),\n",
        "    x=\"value\", # Make our horizontal axis display the % utilisation of the resource in the run\n",
        "    y=\"variable\", # Make the y axis the utilisation category (will be our original column names)\n",
        "    points=\"all\", # Force the boxplot to actually show the individual points too, not just a summary\n",
        "    title=\"Resource Utilisation\", # Add a plot title\n",
        "    # Force the plot to start at 0 regardless of the lowest utilisation recorded\n",
        "    # and finish just past 100 so that the higher points can be seen\n",
        "    range_x=[0, 105],\n",
        "    # Again, use our NHS colour paletted - this will just use NHS blue (the first colour in the list)\n",
        "    color_discrete_sequence=nhs_colour_sequence,\n",
        "    # Tidy up the x and y axis labels\n",
        "    labels={\"variable\": \"\",\n",
        "            \"value\": \"Resource Utilisation Across Run (%)\"\n",
        "            }\n",
        ")\n",
        "\n",
        "# We don't need to do any additional tweaks to the plot this time - we can just display it\n",
        "# straight away\n",
        "utilisation_boxplot_fig.show()\n",
        "\n",
        "##############################################\n",
        "# Bar plot - resource utilisation per run    #\n",
        "##############################################\n",
        "\n",
        "# We're going to use the same data as for our boxplot, but we're more interested in looking\n",
        "# at the utilisation of resources within a single run rather than the consistency of resource\n",
        "# use of a particular resource type, which the boxplot is better at demonstrating\n",
        "# So once again - same data, different focus!\n",
        "utilisation_bar_fig = px.bar(\n",
        "    # First we need to get the dataframe into the shape needed by the plot\n",
        "    # We start by only selecting the utilisation columns by passing a list of\n",
        "    # the column names inside another set of square brackets\n",
        "    (df_trial_results[[\"GP Utilisation - Percentage\",\n",
        "                 \"Receptionist Utilisation - Percentage\"]]\n",
        "                 # once again we want the run number to be a column, not the index\n",
        "                 .reset_index(drop=False)\n",
        "                 # and once again we want it in long format (see the first plot for details)\n",
        "                 .melt(id_vars=\"Run Number\")),\n",
        "    x=\"Run Number\", # The value for our horizontal plot\n",
        "    y=\"value\", # What will be displayed on the vertical axis (here, utilisation %)\n",
        "    # This will colour the bars by a factor\n",
        "    # Here, because we melted our dataframe into long format, the values of the column 'variable'\n",
        "    # are the names of our original columns - i.e. \"GP Utilisation - Percentage\" or\n",
        "    # \"Receptionist Utilisation - Percentage\". We will automatically get a legend thanks to plotly.\n",
        "    color=\"variable\",\n",
        "    # Force the bars to display side-by-side instead of on top of each other (which wouldn't really\n",
        "    # make sense in this graph)\n",
        "    barmode=\"group\",\n",
        "    # Use our NHS colour palette - this time as we have two possible values in the column we coloured\n",
        "    # by, it will use the first two values in the colour palette (NHS blue and NHS warm yellow)\n",
        "    color_discrete_sequence=nhs_colour_sequence,\n",
        "    title=\"Resource Utilisation\",\n",
        "    labels={\"variable\": \"\", # Remove the legend header - it's clear enough without it\n",
        "            \"value\": \"Resource Utilisation Across Run (%)\" # tidy up our y-axis label\n",
        "            }\n",
        ")\n",
        "\n",
        "# Ensure the run label appears on the x axis for each run unless there are lots of them, in\n",
        "# which case we'll just leave the value of dtick as the default (which means plotly will choose\n",
        "# a sensible value for us)\n",
        "if g.number_of_runs < 20:\n",
        "    utilisation_bar_fig.update_layout(xaxis = {'dtick': 1})\n",
        "\n",
        "# Show the bar plot\n",
        "utilisation_bar_fig.show()\n",
        "\n",
        "##############################################################\n",
        "###########################################################\n",
        "# Create some summaries and visualisations for call stats #\n",
        "###########################################################\n",
        "##############################################################\n",
        "\n",
        "##############################################\n",
        "# Dataframe - Call Answering Stats           #\n",
        "##############################################\n",
        "\n",
        "# It would be good to be able to display whether callers had their call answered or not - this\n",
        "# can give us a quick overview of whether the system has been particularly overloaded on different\n",
        "# runs. If a large number of callers never get their call answered, this suggests we need more\n",
        "# receptionists (as they are the ones dealing will registration, test booking and calls in\n",
        "# this model)\n",
        "\n",
        "# Adds a column for whether the call was answered\n",
        "# We use np.where as a bit of an 'if'/'case when' statement here\n",
        "caller_results[\"Call Answered\"] = np.where(\n",
        "    # First, we check a condition - is the value in the 'call answered at' column\n",
        "    # NA/missing?\n",
        "    caller_results[\"Call Answered At\"].isna(),\n",
        "    # If it is, then it means we never recorded a 'call answered at' time because a receptionist\n",
        "    # resource never became free for this caller - so return the string below\n",
        "    \"Call Not Answered Before Closing Time\",\n",
        "    # If it is not na (i.e. the method .isna() returns False), then we can be confident that the\n",
        "    # call was answered\n",
        "    \"Call Answered\"\n",
        "    )\n",
        "\n",
        "# Now let's group by run, keep just our new 'call answered' column, and count how many calls per run\n",
        "# fell into each of these categories.\n",
        "# As the 'value_counts()' method returns a pandas series instead of a pandas dataframe, we need to\n",
        "# manually turn it back into a dataframe first\n",
        "calls_answered_df = pd.DataFrame(\n",
        "    caller_results.groupby(\"Run\")[\"Call Answered\"].value_counts()\n",
        "# Finally, we reset the index (as due to grouping by 'Run' that will have been the index of\n",
        "# the new column we created, but for plotting and pivoting purposes it's easier if that's an\n",
        "# actual column instead)\n",
        ").reset_index(drop=False)\n",
        "\n",
        "# For display purposes, it would actually be easier to read if our dataframe was in 'wide' format -\n",
        "# which will mean that we have a column for 'call answered by closing time' and a column for\n",
        "# 'call not answered before closing time' and a row per run, with the cells then containing\n",
        "# the count of calls per run falling into each of those categories\n",
        "# We use the 'pivot' function for going from long to wide format\n",
        "calls_answered_df_wide = calls_answered_df.pivot(\n",
        "    index=\"Run\", columns=\"Call Answered\", values=\"count\"\n",
        "    ).reset_index(drop=False)\n",
        "\n",
        "# Finally, let's display this dataframe\n",
        "print(calls_answered_df_wide)\n",
        "\n",
        "##########################################################################\n",
        "# Stacked Bar Plot - Percentage of Calls Answered - by run              #\n",
        "##########################################################################\n",
        "\n",
        "# We can now use the long version of this dataframe to create a stacked bar plot\n",
        "# exploring the total number of calls received - and those not answered - within\n",
        "# the plot\n",
        "calls_answered_fig = px.bar(\n",
        "    # we can just pass in our 'call_answered_df' without further modification\n",
        "    calls_answered_df,\n",
        "    x=\"Run\", # The run should be the x axis\n",
        "    y=\"count\", # The number of calls falling into each category should by the y axis\n",
        "    color=\"Call Answered\", # This time we colour the dataframe by whether the call was answered or not\n",
        "    # Tidy up the y axis label (x axis label and legend title are already fine)\n",
        "    labels={\"count\": \"Number of Calls\"},\n",
        "    # Pass in our colour sequence - the first category alphabetically will use colour 1,\n",
        "    # and the second category will use colour 2. If we had more categories, it would continue to\n",
        "    # make its way through the list of colours we defined\n",
        "    color_discrete_sequence=nhs_colour_sequence,\n",
        "    # Add a plot title\n",
        "    title=\"Number of Calls - How Many Were Answered in Opening Hours?\"\n",
        ")\n",
        "\n",
        "# Ensure each column has a number on the x axis (if there aren't too many runs)\n",
        "if g.number_of_runs < 20:\n",
        "    calls_answered_fig.update_layout(xaxis = {'dtick': 1})\n",
        "\n",
        "# Show the plot\n",
        "calls_answered_fig.show()\n",
        "\n",
        "##############################################\n",
        "# Strip Plot - Arrival Patterns              #\n",
        "##############################################\n",
        "\n",
        "# Finally, let's make a scatterplot that can help us to just check that the patterns of arrivals\n",
        "# across the day makes sense. Are the callers and patients arriving in an intermingled fashion\n",
        "# and do we have some of each?\n",
        "# This plot might be of more use for debugging than actually understanding the model behaviour -\n",
        "# although it can also be useful to demonstrate that the arrival times are not fixed across\n",
        "# the different runs, which can help people to understand the value and functioning of the model\n",
        "\n",
        "# We start by joining the patient and caller results together\n",
        "calls_and_patients = pd.concat([\n",
        "        # we only want a few columns from each\n",
        "        patient_results[[\"Run\", \"Arrival Time\", \"What\"]],\n",
        "        # It's important that the columns are in the same order and have the same names\n",
        "        # as we are just going to stack them on top of each other\n",
        "        caller_results[[\"Run\", \"Call Start Time\", \"What\"]].rename(columns={\"Call Start Time\": \"Arrival Time\"})\n",
        "        ])\n",
        "\n",
        "# Here we are going to use something called a strip plot, which is a scatterplot (a plot with\n",
        "# a series of dots - but with some level of randomness on one axis to ensure points at exactly\n",
        "# the same position don't fully overlap)\n",
        "arrival_fig = px.strip(\n",
        "    # We pass in the dataframe we just created\n",
        "    calls_and_patients,\n",
        "    # We place the points horizontally depending on the time the individual caller or patient\n",
        "    # arrived in the model\n",
        "    x=\"Arrival Time\",\n",
        "    # We then use the run number on the y axis, which will give us a line of points per run\n",
        "    y=\"Run\",\n",
        "    # We'll use the colour to distinguish between patients and callers\n",
        "    color=\"What\",\n",
        "    # We'll use our colour palette\n",
        "    color_discrete_sequence=nhs_colour_sequence,\n",
        "    # Finally, let's add a title\n",
        "    title=\"Patient Arrivals by Time\",\n",
        "    labels={\"Arrival Time\": \"Arrival Time (Simulation Minute)\"}\n",
        ")\n",
        "\n",
        "# Force the maximum amount of jitter (random offset) in the points\n",
        "arrival_fig.update_traces(jitter=1.0)\n",
        "\n",
        "# Display the plot\n",
        "arrival_fig.show()\n",
        "\n",
        "############################################################\n",
        "# Strip Plot - Call Answering by Arrival Time              #\n",
        "############################################################\n",
        "\n",
        "# We can also use a similar point to give an indication of at what point our system\n",
        "# starts to overload during each run.\n",
        "# Instead of displaying both patients and callers, we use just the callers this time\n",
        "call_answered_detailed_fig = px.strip(\n",
        "    # We pass in the dataframe we just created\n",
        "    caller_results,\n",
        "    # We place the points horizontally depending on the time the individual caller or patient\n",
        "    # arrived in the model\n",
        "    x=\"Call Start Time\",\n",
        "    # We then use the run number on the y axis, which will give us a line of points per run\n",
        "    y=\"Run\",\n",
        "    # We'll use the colour to distinguish between patients and callers\n",
        "    color=\"Call Answered\",\n",
        "    # This time, instead of using our palette, let's explicitly map some colours to the possible\n",
        "    # values\n",
        "    # This allows us to ensure the 'not answered' gets associated with a typically 'bad' colour\n",
        "    color_discrete_map={\"Call Answered\": \"#005EB8\", # NHS blue\n",
        "                        \"Call Not Answered Before Closing Time\": \"#DA291C\"}, # NHS Red\n",
        "    # Finally, let's add a title\n",
        "    title=\"Patient Calls - Successful Answering over Time\",\n",
        "    # Make it clearer what the units of the x axis are\n",
        "    labels={\"Call Start Time\": \"Call Start Time (Simulation Minute)\"},\n",
        ")\n",
        "\n",
        "call_answered_detailed_fig.show()\n",
        "\n",
        "##############################################################\n",
        "##############################################################\n",
        "# Create some summaries and visualisations for patient stats #\n",
        "##############################################################\n",
        "##############################################################\n",
        "\n",
        "\n",
        "# Not implemented - your code here!"
      ],
      "id": "2ea38123",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/opt/homebrew/Caskroom/miniconda/base/envs/hsma_reproducible_reporting/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}